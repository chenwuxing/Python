#正则表达式  
正则表达式是一种用来匹配字符串的强有力的武器，它的设计思想使用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。  
##在正则表达式中，如果给出字符，就是精确匹配  
&ensp;  用\d可以匹配一个字母或者数字，\w可以匹配一个字符或者数字，\.可以匹配任意字符。  
##匹配变长的字符  
&ensp;  在正则表达式中用*表示任意个字符(包括0个)，用\+表示至少一个字符，用\?表示0个或1个字符，用\{n}表示n个字符，用\{n,m}表示n-m个字符。  
##进阶精确匹配  
&ensp;  要做更精确地匹配，可以用[]表示范围  
```  
[0-9a-zA-Z\_]可以匹配一个数字 字母或者下滑线
[0-9a-zA-Z\_]+ 可以匹配至少由一个数字 字母或者下滑线组成的字符串
[a-zA-Z\_][0-9a-zA-Z\_]* 可以匹配由字母或者下划线开头，后接任意个由一个数字 字母或者下划线组成的字符串
[0-9a-zA-Z\_][0-9a-zA-Z\_]{0,19}更精确地限制了变量的长度是1-20个字符 
A|B可以匹配A或者B  
^表示行的开头
$表示行的结束
```  
##re模块  
###判断正则表达式是否匹配  
&ensp;  match()方法判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None。  
###切分字符串  
![](https://i.imgur.com/PKs1e62.png)  
 
##分组  
&ensp;  除了简单的判断是否匹配外，正则表达式还有提取子串的强大功能。用()表示的就是要提取的分组，例如^(\d{3})-(\d{3,8))$分别定义了两个组  
![](https://i.imgur.com/cvyIJfI.png)  
&ensp;  如果正则表达式中定义了组，就可以在Match对象上用group（）方法提取出子串来，group(0)永远是原始字符串，group(1)、group(2)表示第1、2个子串。  
##贪婪匹配  
&ensp;  正则匹配默认是贪婪匹配，就是匹配尽可能多的字符。  
![](https://i.imgur.com/WQwypla.png)  
&ensp;  由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符。  
##编译  
&ensp;  当我们在python使用正则表达式时，re模块内部会干两件事  
- 编译正则表达式，如果正则表达式的字符串本身不合法，会报错。  
- 用编译后的正则表达式去匹配字符串。  
**如果一个正则表达式要使用几千次，出于效率的考虑，我们可以预编译该正则表达式，接下来重复使用就不需要编译这个步骤了，直接匹配**  
![](https://i.imgur.com/jdUtgRJ.png)  

